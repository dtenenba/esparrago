package main

import (
	"errors"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"html/template"
	"os"
	"strconv"
	"strings"
)

const (
	template1 = `
/* DO NOT EDIT THIS FILE - it is generated by 'esparrago'. */
{{ if .DefineUseRinternals }}#define USE_RINTERNALS{{ end }}
{{ if .IncludeRHeader }}#include <R.h>{{ end }}
{{ if .IncludeRinternalsHeader }}#include <Rinternals.h>{{end }}
#include "_cgo_export.h"

//helper functions
SEXP IntegerVectorFromGoSlice( void* data, int n ){
  SEXP res = allocVector( INTSXP, n) ;
  memmove( INTEGER(res), data, sizeof(int)*n ) ;
  return res ;
}

// begin C stubs for Go functions

{{range .ExportedFunctions}}

// C stub for Go function {{ .FunctionName  }}
{{ .ReturnType }} {{ .CStubName }}({{.Arguments|JoinCFuncArgs}}) {
  // something happens here
  {{if .HasReturnValue}}return {{.|ReturnValue}} ;{{end}}
}




{{end}}

	`
)

type templateData struct {
	DefineUseRinternals     bool
	IncludeRHeader          bool
	IncludeRinternalsHeader bool
	ExportedFunctions       []ExportedFunction
}

// ExportedFunction is used in templates.
type ExportedFunction struct {
	HasReturnValue bool
	ReturnType     string
	FunctionName   string
	CStubName      string
	Arguments      []Argument
}

// Argument is used in templates.
type Argument struct {
	ArgType string
	ArgName string
	CName   string
}

type badExportError struct{ error }
type receiverError struct{ error }
type multipleReturnValuesError struct{ error }
type badImportError struct{ error }
type wrongPackageError struct{ error }
type noMainFunctionError struct{ error }
type nonEmptyMainFunctionError struct{ error }
type noFunctionsToExportError struct{ error }
type noArgsOrReturnValuesError struct{ error }

func getExportedFunctions(filename string, src interface{}) (
	exportedFuncs []*ast.FuncDecl, err error) {
	// FIXME make this work with `go generate`; be sure and handle the
	// `go generate` comment line in source files we process, don't associate it with
	// a function (like an export comment).
	fset := token.NewFileSet() // positions are relative to fset

	f, err := parser.ParseFile(fset, filename, src, parser.ParseComments)
	if err != nil {
		return nil, err
	}

	if f.Name.Name != "main" {
		return nil,
			wrongPackageError{fmt.Errorf("Package name '%s' invalid, must be 'main'.",
				f.Name.Name)}
	}

	foundC := false
	for _, anImport := range f.Imports {
		importPath := anImport.Path.Value
		for _, quoter := range []string{"\"", "'", "`"} {
			importPath = strings.Replace(importPath, quoter, "", -1)
			if importPath == "C" {
				foundC = true
				break
			}
		}
	}
	if !foundC {
		return nil, badImportError{errors.New("You must import \"C\"!")}
	}

	// cmap := ast.NewCommentMap(fset, f, f.Comments)

	var keepers []*ast.FuncDecl
	foundMainFunction := false

	for _, decl := range f.Decls {
		fn, ok := decl.(*ast.FuncDecl)
		if !ok {
			continue
		}
		fmt.Println("func name", fn.Name.Name)
		fmt.Println("doc", fn.Doc)
		if fn.Name.Name == "main" {
			if len(fn.Body.List) > 0 {
				return nil,
					nonEmptyMainFunctionError{errors.New("main function must be empty")}
			}
			foundMainFunction = true
		}
		if fn.Doc != nil {
			for _, comment := range fn.Doc.List {
				fmt.Println("comment", comment.Text)
				if strings.HasPrefix(comment.Text, "//export ") {
					segs := strings.Split(comment.Text, " ")
					exportedFunc := segs[len(segs)-1]
					if exportedFunc != fn.Name.Name {
						return nil,
							badExportError{
								fmt.Errorf(
									"Function name in comment (%s) does not match function name in function (%s)\n",
									exportedFunc, fn.Name.Name)}
					}
					if fn.Recv != nil {
						return nil, receiverError{
							errors.New("Can't export methods to other languages, only functions.")}
					}
					if fn.Type.Results != nil {
						fmt.Println("output is", fn.Type.Results.List)
						for _, field := range fn.Type.Results.List {
							fmt.Println("  type is ", field.Type)
						}
						if fn.Type.Results.NumFields() > 1 {
							return nil,
								multipleReturnValuesError{
									fmt.Errorf("Function %s must return 0 or 1 items, not %d\n",
										fn.Name.Name, fn.Type.Results.NumFields())}
						}
					}
					for _, param := range fn.Type.Params.List {
						fmt.Println("  param type is", param.Type)
						fmt.Println("  param names", param.Names)
					}

					if fn.Type.Results.NumFields() == 0 &&
						fn.Type.Params.NumFields() == 0 {
						return nil,
							noArgsOrReturnValuesError{fmt.Errorf(
								"Function %s has no args or return values.",
								fn.Name.Name)}
					}
					// assume this func is ok
					keepers = append(keepers, fn)
				}
			}
		}
		// fmt.Println(fn)
	}
	if !foundMainFunction {
		return nil, noMainFunctionError{errors.New("No main() function")}
	}

	if len(keepers) == 0 {
		return nil, noFunctionsToExportError{errors.New("No functions to export")}
	}

	return keepers, nil
}

//JoinCFuncArgs is passed to the template
func JoinCFuncArgs(cargs []Argument) string {
	argStrs := []string{}
	for _, arg := range cargs {
		argStrs = append(argStrs, fmt.Sprintf("%s %s", arg.ArgType, arg.ArgName))
	}
	return strings.Join(argStrs, ", ")
}

func getWrappedCFunction(goReturnType string) string {
	switch goReturnType {
	case "int": // Unfortunately this is the only case I know about so far...
		return "Rf_ScalarInteger"
	}
	panic(fmt.Sprintf("Don't know the wrapped C function for return type %s.",
		goReturnType))

}

func getCRepresentationOfArgument(arg Argument) string {
	switch arg.ArgType {
	case "int":
		return fmt.Sprintf("INTEGER(%s)[0]", arg.ArgName)
	}
	panic(fmt.Sprintf("Don't know the C representation for argument type %s.",
		arg.ArgType))
}

func transformArgument(arg *Argument) {

}

//ReturnValue is passed to the template
func ReturnValue(fn ExportedFunction) string {
	/*
		Given a Go function:

		//export DoubleIt
		func DoubleIt(x int) int {
			return x * 2
		}

		We want C like this:

		SEXP DoubleIt_cstub(SEXP x){
		  return Rf_ScalarInteger( DoubleIt( INTEGER(x)[0] ) ) ;
		}
		The job of this function is to return everything after the
		"return " in the C code above, up-to (but not including) the semi-colon,
		so in this case:
		Rf_ScalarInteger( DoubleIt( INTEGER(x)[0] ) )

	*/

	return ("bla bla bla")
}

func generateCcode(exportedFuncs []*ast.FuncDecl) (ok bool, err error) { // TODO only need 1 return value?
	td := templateData{}
	td.DefineUseRinternals = true
	td.IncludeRHeader = true
	td.IncludeRinternalsHeader = true

	for _, funk := range exportedFuncs {
		cfunc := ExportedFunction{}
		cfunc.FunctionName = funk.Name.Name
		cfunc.CStubName = fmt.Sprintf("%s_cstub", funk.Name.Name)
		if funk.Type.Results.NumFields() == 0 {
			cfunc.ReturnType = ""
			cfunc.HasReturnValue = false
		} else {
			cfunc.ReturnType = "SEXP" // for now; probably need to have more logic later (void funcs, etc)
			cfunc.HasReturnValue = true
		}
		for _, arg := range funk.Type.Params.List {
			// FIXME for now we are ignoring args like x, y int
			// we should at least have a test that rejects these until we are ready to handle them
			cargs := Argument{}
			cargs.ArgName = arg.Names[0].Name // only using first one!
			// goArgType := fmt.Sprintf("%v", arg.Type)
			cargs.ArgType = "SEXP" // for now...
			cfunc.Arguments = append(cfunc.Arguments, cargs)
		}
		td.ExportedFunctions = append(td.ExportedFunctions, cfunc)
	}
	t := template.New("Ccode")
	t = t.Funcs(template.FuncMap{
		"JoinCFuncArgs": JoinCFuncArgs,
		"ReturnValue":   ReturnValue,
	})

	t, err = t.Parse(template1)
	if err != nil {
		return false, fmt.Errorf("Error parsing template: %s", err)
	}
	err = t.Execute(os.Stdout, td) // FIXME change Stdout to file provided by user
	if err != nil {
		return false, fmt.Errorf("Error executing template: %s", err)
	}
	return true, nil
	// ...

	// outfh, err := os.Create(outputFilename)
	// if err != nil {
	// 	os.Stderr.WriteString(fmt.Sprintf("Error opening output file %s: %s",
	// 		os.Args[2], err.Error()))
	// 	exit(1)
	// 	return
	// }
	// defer outfh.Close()
	// // if _, err = io.WriteString(outfh, "here is some output\n"); err != nil {
	// // 	os.Stderr.WriteString(fmt.Sprintf("Error writing to output file %s: %s",
	// // 		os.Args[2], err.Error()))
	// // 	exit(1)
	// // 	return
	// // }
	// err = outfh.Sync() // see https://joeshaw.org/dont-defer-close-on-writable-files/
	// if err != nil {
	// 	os.Stderr.WriteString(fmt.Sprintf("Error syncing output file %s to disk: %s",
	// 		os.Args[2], err.Error()))
	// 	exit(1)
	// 	return
	// }

}

func exit(exitCode int) int {
	if _, ok := os.LookupEnv("TESTING_ESPARRAGO"); ok {
		os.Setenv("ESPARRAGO_EXIT_CODE", strconv.Itoa(exitCode))
	} else { // These three lines can't be covered by tests
		os.Exit(exitCode) // without a lot of
	} // hassle.
	return exitCode
}

func main() {
	if len(os.Args) != 3 {
		fmt.Printf("Usage: %s inputfile.go outputfile.c\n", os.Args[0])
		exit(1)
		return
	}
	exportedFuncs, err := getExportedFunctions(os.Args[1], nil)
	if err != nil {
		os.Stderr.WriteString(err.Error()) // errors to stderr, save stdout for correct output
		os.Stderr.WriteString("\n")
		exit(1)
		return
	}

	_, err = generateCcode(exportedFuncs)
	if err != nil {
		os.Stderr.WriteString(err.Error()) // errors to stderr, save stdout for correct output
		os.Stderr.WriteString("\n")
		exit(1)
		return
	}
}
